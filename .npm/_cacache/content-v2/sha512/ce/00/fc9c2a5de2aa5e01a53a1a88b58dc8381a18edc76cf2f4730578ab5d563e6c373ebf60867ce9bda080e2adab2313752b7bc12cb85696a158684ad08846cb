{
  "_id" : "diff-sequences",
  "_rev" : "35-a1c3eae61e53f22918db8df00a02ed2e",
  "name" : "diff-sequences",
  "description" : "Compare items in two sequences to find a longest common subsequence",
  "dist-tags" : {
    "next" : "25.0.0",
    "beta" : "24.2.0-alpha.0",
    "latest" : "25.1.0"
  },
  "versions" : {
    "24.0.0-alpha.16" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "24.0.0-alpha.16",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git",
        "directory" : "packages/diff-sequences"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "engines" : {
        "node" : ">= 6"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-24.0.0-alpha.16.tgz",
        "shasum" : "7d80b224c276f74807f6149f4f57aaadc0f695bc"
      },
      "devDependencies" : {
        "benchmark" : "^2.1.4",
        "diff" : "^4.0.1"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "jean@lauliac.com",
        "name" : "jeanlauliac"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      }, {
        "email" : "rubennorte@gmail.com",
        "name" : "rubennorte"
      } ],
      "directories" : {
      },
      "scripts" : {
        "perf" : "node --expose-gc perf/index.js"
      },
      "_npmVersion" : "lerna/3.10.5/node@v8.11.3+x64 (darwin)",
      "_npmUser" : {
        "name" : "rubennorte",
        "email" : "rubennorte@gmail.com"
      },
      "_id" : "diff-sequences@24.0.0-alpha.16",
      "gitHead" : "634e5a54f46b2a62d1dc81a170562e6f4e55ad60",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_24.0.0-alpha.16_1548423707835_0.8804922598482618"
      },
      "readme" : "# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.11.3"
    },
    "24.0.0" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "24.0.0",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git",
        "directory" : "packages/diff-sequences"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "engines" : {
        "node" : ">= 6"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-24.0.0.tgz",
        "shasum" : "cdf8e27ed20d8b8d3caccb4e0c0d8fe31a173013"
      },
      "devDependencies" : {
        "benchmark" : "^2.1.4",
        "diff" : "^4.0.1"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "jean@lauliac.com",
        "name" : "jeanlauliac"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      }, {
        "email" : "rubennorte@gmail.com",
        "name" : "rubennorte"
      } ],
      "directories" : {
      },
      "scripts" : {
        "perf" : "node --expose-gc perf/index.js"
      },
      "_npmVersion" : "lerna/3.10.5/node@v8.11.3+x64 (darwin)",
      "_npmUser" : {
        "name" : "rubennorte",
        "email" : "rubennorte@gmail.com"
      },
      "_id" : "diff-sequences@24.0.0",
      "gitHead" : "634e5a54f46b2a62d1dc81a170562e6f4e55ad60",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_24.0.0_1548428682371_0.9163471860444559"
      },
      "_nodeVersion" : "8.11.3"
    },
    "24.0.0-alpha.15" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "24.0.0-alpha.15",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git",
        "directory" : "packages/diff-sequences"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "engines" : {
        "node" : ">= 6"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-24.0.0-alpha.15.tgz",
        "shasum" : "29c6aad320390ac8b9f5ba48b99939fc7c4815e7"
      },
      "devDependencies" : {
        "benchmark" : "^2.1.4",
        "diff" : "^4.0.1"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "jean@lauliac.com",
        "name" : "jeanlauliac"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      }, {
        "email" : "rubennorte@gmail.com",
        "name" : "rubennorte"
      } ],
      "directories" : {
      },
      "scripts" : {
        "perf" : "node --expose-gc perf/index.js"
      },
      "_npmVersion" : "lerna/3.10.5/node@v8.11.3+x64 (darwin)",
      "_npmUser" : {
        "name" : "rubennorte",
        "email" : "rubennorte@gmail.com"
      },
      "_id" : "diff-sequences@24.0.0-alpha.15",
      "gitHead" : "28971c5f794330e8acc6861288e6daafcd32238e",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_24.0.0-alpha.15_1548352336663_0.6978139683358666"
      },
      "readme" : "# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.11.3"
    },
    "24.0.0-alpha.12" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "24.0.0-alpha.12",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "engines" : {
        "node" : ">= 6"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-24.0.0-alpha.12.tgz",
        "shasum" : "88cc5aebf11c60b5bfe01414a10e434d4e45311a"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "jean@lauliac.com",
        "name" : "jeanlauliac"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      }, {
        "email" : "rubennorte@gmail.com",
        "name" : "rubennorte"
      } ],
      "directories" : {
      },
      "_npmVersion" : "5.6.0",
      "_npmUser" : {
        "name" : "rubennorte",
        "email" : "rubennorte@gmail.com"
      },
      "_id" : "diff-sequences@24.0.0-alpha.12",
      "gitHead" : "4f2bcb861d1f0fb150c05970362e52a38c31f67e",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_24.0.0-alpha.12_1547218682692_0.19852421640191076"
      },
      "readme" : "# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.11.3"
    },
    "24.0.0-alpha.13" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "24.0.0-alpha.13",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git",
        "directory" : "packages/diff-sequences"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "engines" : {
        "node" : ">= 6"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-24.0.0-alpha.13.tgz",
        "shasum" : "f76ba219d05c5495f71a78316427c4b9c2cdca5c"
      },
      "devDependencies" : {
        "benchmark" : "^2.1.4",
        "diff" : "^4.0.1"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "jean@lauliac.com",
        "name" : "jeanlauliac"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      }, {
        "email" : "rubennorte@gmail.com",
        "name" : "rubennorte"
      } ],
      "directories" : {
      },
      "scripts" : {
        "perf" : "node --expose-gc perf/index.js"
      },
      "_npmVersion" : "lerna/3.10.5/node@v8.11.3+x64 (darwin)",
      "_npmUser" : {
        "name" : "rubennorte",
        "email" : "rubennorte@gmail.com"
      },
      "_id" : "diff-sequences@24.0.0-alpha.13",
      "gitHead" : "6de22dde9a10f775adc7b6f80080bdd224f6ae31",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_24.0.0-alpha.13_1548256516166_0.37449123475823987"
      },
      "readme" : "# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.11.3"
    },
    "24.0.0-alpha.10" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "24.0.0-alpha.10",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "engines" : {
        "node" : ">= 6"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-24.0.0-alpha.10.tgz",
        "shasum" : "d9bb880f84078eb01aa4a72d9782d138e50c84cf"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "jean@lauliac.com",
        "name" : "jeanlauliac"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      }, {
        "email" : "rubennorte@gmail.com",
        "name" : "rubennorte"
      } ],
      "directories" : {
      },
      "_npmVersion" : "5.6.0",
      "_npmUser" : {
        "name" : "rubennorte",
        "email" : "rubennorte@gmail.com"
      },
      "_id" : "diff-sequences@24.0.0-alpha.10",
      "gitHead" : "722049ccd66947d48296dcb666bc99fccab86065",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_24.0.0-alpha.10_1547053258708_0.6037156508529322"
      },
      "readme" : "# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.11.3"
    },
    "24.0.0-alpha.11" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "24.0.0-alpha.11",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "engines" : {
        "node" : ">= 6"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-24.0.0-alpha.11.tgz",
        "shasum" : "cb6bc9ebb9c4bc3f5e6bafaac786b326124a3fbb"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "jean@lauliac.com",
        "name" : "jeanlauliac"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      }, {
        "email" : "rubennorte@gmail.com",
        "name" : "rubennorte"
      } ],
      "directories" : {
      },
      "_npmVersion" : "5.6.0",
      "_npmUser" : {
        "name" : "rubennorte",
        "email" : "rubennorte@gmail.com"
      },
      "_id" : "diff-sequences@24.0.0-alpha.11",
      "gitHead" : "6a066c6afe2ae08669a27d3b703a6cf0d898e7b7",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_24.0.0-alpha.11_1547145684380_0.5361225083077126"
      },
      "readme" : "# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.11.3"
    },
    "24.9.0" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "24.9.0",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git",
        "directory" : "packages/diff-sequences"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "engines" : {
        "node" : ">= 6"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-24.9.0.tgz",
        "shasum" : "5715d6244e2aa65f48bba0bc972db0b0b11e95b5"
      },
      "devDependencies" : {
        "benchmark" : "^2.1.4",
        "diff" : "^4.0.1"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "jean@lauliac.com",
        "name" : "jeanlauliac"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      }, {
        "email" : "rubennorte@gmail.com",
        "name" : "rubennorte"
      }, {
        "email" : "scott.hovestadt@gmail.com",
        "name" : "scotthovestadt"
      } ],
      "directories" : {
      },
      "scripts" : {
        "perf" : "node --expose-gc perf/index.js"
      },
      "publishConfig" : {
        "access" : "public"
      },
      "_npmVersion" : "lerna/3.15.0/node@v11.12.0+x64 (darwin)",
      "_npmUser" : {
        "name" : "scotthovestadt",
        "email" : "scott.hovestadt@gmail.com"
      },
      "_id" : "diff-sequences@24.9.0",
      "gitHead" : "9ad0f4bc6b8bdd94989804226c28c9960d9da7d1",
      "types" : "build/index.d.ts",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_24.9.0_1565934946970_0.6896997727763712"
      },
      "_nodeVersion" : "11.12.0"
    },
    "24.2.0" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "24.2.0",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git",
        "directory" : "packages/diff-sequences"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "engines" : {
        "node" : ">= 6"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-24.2.0.tgz",
        "shasum" : "605025e678673636d82c49eda94a9cebcbf4b648"
      },
      "devDependencies" : {
        "benchmark" : "^2.1.4",
        "diff" : "^4.0.1"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "jean@lauliac.com",
        "name" : "jeanlauliac"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      }, {
        "email" : "rubennorte@gmail.com",
        "name" : "rubennorte"
      } ],
      "directories" : {
      },
      "scripts" : {
        "perf" : "node --expose-gc perf/index.js"
      },
      "_npmVersion" : "lerna/3.13.1/node@v8.10.0+x64 (darwin)",
      "_npmUser" : {
        "name" : "mjesun",
        "email" : "mjesun@hotmail.com"
      },
      "_id" : "diff-sequences@24.2.0",
      "gitHead" : "d23f1ef18567763ab0133372e376ae5026a23d4b",
      "types" : "build/index.d.ts",
      "deprecated" : "This version was accidentally published and might contain errors. Please use 24.0.0 or a newer release",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_24.2.0_1551784963744_0.9274550559945209"
      },
      "_nodeVersion" : "8.10.0"
    },
    "24.3.0" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "24.3.0",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git",
        "directory" : "packages/diff-sequences"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "engines" : {
        "node" : ">= 6"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-24.3.0.tgz",
        "shasum" : "0f20e8a1df1abddaf4d9c226680952e64118b975"
      },
      "devDependencies" : {
        "benchmark" : "^2.1.4",
        "diff" : "^4.0.1"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "jean@lauliac.com",
        "name" : "jeanlauliac"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      }, {
        "email" : "rubennorte@gmail.com",
        "name" : "rubennorte"
      } ],
      "directories" : {
      },
      "scripts" : {
        "perf" : "node --expose-gc perf/index.js"
      },
      "publishConfig" : {
        "access" : "public"
      },
      "_npmVersion" : "lerna/3.13.1/node@v8.11.3+x64 (darwin)",
      "_npmUser" : {
        "name" : "rubennorte",
        "email" : "rubennorte@gmail.com"
      },
      "_id" : "diff-sequences@24.3.0",
      "gitHead" : "3a7a4f3a3f5489ac8e07dcddf76bb949c482ec87",
      "types" : "build/index.d.ts",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_24.3.0_1551963558692_0.7852251620556123"
      },
      "_nodeVersion" : "8.11.3"
    },
    "0.0.0" : {
      "name" : "diff-sequences",
      "description" : "",
      "version" : "0.0.0",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-0.0.0.tgz",
        "shasum" : "0b3376e68c02ff5bbca4bb0d0bfe26ab67503bf7"
      },
      "maintainers" : [ {
        "name" : "cpojer",
        "email" : "christoph.pojer@gmail.com"
      } ],
      "directories" : {
      },
      "_npmVersion" : "5.6.0",
      "_npmUser" : {
        "name" : "cpojer",
        "email" : "christoph.pojer@gmail.com"
      },
      "_id" : "diff-sequences@0.0.0",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_0.0.0_1517992034571_0.7324709934672862"
      },
      "_nodeVersion" : "9.4.0"
    },
    "25.0.0" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "25.0.0",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git",
        "directory" : "packages/diff-sequences"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "engines" : {
        "node" : ">= 8"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-25.0.0.tgz",
        "shasum" : "12e39d89da8c559b4eceef169260d9175683509c"
      },
      "devDependencies" : {
        "benchmark" : "^2.1.4",
        "diff" : "^4.0.1"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "jean@lauliac.com",
        "name" : "jeanlauliac"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      }, {
        "email" : "rubennorte@gmail.com",
        "name" : "rubennorte"
      }, {
        "email" : "scott.hovestadt@gmail.com",
        "name" : "scotthovestadt"
      } ],
      "directories" : {
      },
      "scripts" : {
        "perf" : "node --expose-gc perf/index.js"
      },
      "publishConfig" : {
        "access" : "public"
      },
      "_npmVersion" : "lerna/3.16.4/node@v11.12.0+x64 (darwin)",
      "_npmUser" : {
        "name" : "scotthovestadt",
        "email" : "scott.hovestadt@gmail.com"
      },
      "_id" : "diff-sequences@25.0.0",
      "gitHead" : "ff9269be05fd8316e95232198fce3463bf2f270e",
      "types" : "build/index.d.ts",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_25.0.0_1566444224445_0.703563251151955"
      },
      "readme" : "# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "11.12.0"
    },
    "24.0.0-alpha.9" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "24.0.0-alpha.9",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "engines" : {
        "node" : ">= 6"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-24.0.0-alpha.9.tgz",
        "shasum" : "9fb1791b7ef1734b012c80306ba06735f38684e0"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "jean@lauliac.com",
        "name" : "jeanlauliac"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      }, {
        "email" : "rubennorte@gmail.com",
        "name" : "rubennorte"
      } ],
      "directories" : {
      },
      "_npmVersion" : "5.6.0",
      "_npmUser" : {
        "name" : "rubennorte",
        "email" : "rubennorte@gmail.com"
      },
      "_id" : "diff-sequences@24.0.0-alpha.9",
      "gitHead" : "c7caa7ba5904d0c61e586694cde5f536639e4afc",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_24.0.0-alpha.9_1545229373441_0.056509693246487025"
      },
      "readme" : "# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.11.3"
    },
    "24.0.0-alpha.7" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "24.0.0-alpha.7",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-24.0.0-alpha.7.tgz",
        "shasum" : "0dbbe9eeb8cf2690682502750c0f14ff2484c372"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "jean@lauliac.com",
        "name" : "jeanlauliac"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      }, {
        "email" : "rubennorte@gmail.com",
        "name" : "rubennorte"
      } ],
      "directories" : {
      },
      "_npmVersion" : "5.6.0",
      "_npmUser" : {
        "name" : "mjesun",
        "email" : "mjesun@hotmail.com"
      },
      "_id" : "diff-sequences@24.0.0-alpha.7",
      "gitHead" : "4954f46708415174c48a58f296a605fbe1244a31",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_24.0.0-alpha.7_1544544450385_0.8767994851184364"
      },
      "readme" : "# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.10.0"
    },
    "25.1.0" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "25.1.0",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git",
        "directory" : "packages/diff-sequences"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "engines" : {
        "node" : ">= 8.3"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-25.1.0.tgz",
        "shasum" : "fd29a46f1c913fd66c22645dc75bffbe43051f32"
      },
      "devDependencies" : {
        "benchmark" : "^2.1.4",
        "diff" : "^4.0.1"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "davidzilburg@gmail.com",
        "name" : "davidzilburg"
      }, {
        "email" : "jean@lauliac.com",
        "name" : "jeanlauliac"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      }, {
        "email" : "rubennorte@gmail.com",
        "name" : "rubennorte"
      }, {
        "email" : "scott.hovestadt@gmail.com",
        "name" : "scotthovestadt"
      } ],
      "directories" : {
      },
      "scripts" : {
        "perf" : "node --expose-gc perf/index.js"
      },
      "publishConfig" : {
        "access" : "public"
      },
      "_npmVersion" : "lerna/3.20.2/node@v10.16.0+x64 (darwin)",
      "_npmUser" : {
        "name" : "davidzilburg",
        "email" : "davidzilburg@gmail.com"
      },
      "_id" : "diff-sequences@25.1.0",
      "gitHead" : "170eee11d03b0ed5c60077982fdbc3bafd403638",
      "types" : "build/index.d.ts",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_25.1.0_1579654784507_0.9473791596126149"
      },
      "_nodeVersion" : "10.16.0"
    },
    "24.2.0-alpha.0" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "24.2.0-alpha.0",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git",
        "directory" : "packages/diff-sequences"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "engines" : {
        "node" : ">= 6"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-24.2.0-alpha.0.tgz",
        "shasum" : "958be148e0bbb42462eb3594f4a92b3d8019d418"
      },
      "devDependencies" : {
        "benchmark" : "^2.1.4",
        "diff" : "^4.0.1"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "jean@lauliac.com",
        "name" : "jeanlauliac"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      }, {
        "email" : "rubennorte@gmail.com",
        "name" : "rubennorte"
      } ],
      "directories" : {
      },
      "scripts" : {
        "perf" : "node --expose-gc perf/index.js"
      },
      "publishConfig" : {
        "access" : "public"
      },
      "_npmVersion" : "lerna/3.13.1/node@v8.11.3+x64 (darwin)",
      "_npmUser" : {
        "name" : "rubennorte",
        "email" : "rubennorte@gmail.com"
      },
      "_id" : "diff-sequences@24.2.0-alpha.0",
      "gitHead" : "800f2f803d01c8ae194d71b251e4965dd70e5bf2",
      "types" : "build/index.d.ts",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_24.2.0-alpha.0_1551797181846_0.29220347658793466"
      },
      "readme" : "# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.11.3"
    },
    "24.0.0-alpha.1" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "24.0.0-alpha.1",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-24.0.0-alpha.1.tgz",
        "shasum" : "0cb8546f71e6a3d157cb92fe4b0a178e36c48f70"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      } ],
      "directories" : {
      },
      "_npmVersion" : "5.6.0",
      "_npmUser" : {
        "name" : "mjesun",
        "email" : "mjesun@hotmail.com"
      },
      "_id" : "diff-sequences@24.0.0-alpha.1",
      "gitHead" : "4954f46708415174c48a58f296a605fbe1244a31",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_24.0.0-alpha.1_1540222528051_0.5059020296169037"
      },
      "readme" : "# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.10.0"
    },
    "24.0.0-alpha.2" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "24.0.0-alpha.2",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "engines" : {
        "node" : ">= 6"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-24.0.0-alpha.2.tgz",
        "shasum" : "4b23cec46266dd8bf61fe57b1cd1dbd1b6a37d6d"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "jean@lauliac.com",
        "name" : "jeanlauliac"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      }, {
        "email" : "rubennorte@gmail.com",
        "name" : "rubennorte"
      } ],
      "directories" : {
      },
      "_npmVersion" : "5.6.0",
      "_npmUser" : {
        "name" : "rubennorte",
        "email" : "rubennorte@gmail.com"
      },
      "_id" : "diff-sequences@24.0.0-alpha.2",
      "gitHead" : "c5e36835cff4b241327db9cf58c8f6f7227ed1f7",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_24.0.0-alpha.2_1540463500064_0.5225365388805607"
      },
      "_nodeVersion" : "8.11.3"
    },
    "22.4.3" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "22.4.3",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-22.4.3.tgz",
        "shasum" : "48d99ea376fb3f049215ccc8606ff4154f4516bf"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      } ],
      "directories" : {
      },
      "_npmVersion" : "5.5.1",
      "_npmUser" : {
        "name" : "mjesun",
        "email" : "mjesun@hotmail.com"
      },
      "_id" : "diff-sequences@22.4.3",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_22.4.3_1521648478627_0.22926297299456455"
      },
      "_nodeVersion" : "8.9.1"
    },
    "24.0.0-alpha.0" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "24.0.0-alpha.0",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-24.0.0-alpha.0.tgz",
        "shasum" : "797d848ddb4751ceaff3413ac70f78f942e1f39b"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      } ],
      "directories" : {
      },
      "_npmVersion" : "5.6.0",
      "_npmUser" : {
        "name" : "mjesun",
        "email" : "mjesun@hotmail.com"
      },
      "_id" : "diff-sequences@24.0.0-alpha.0",
      "gitHead" : "22f67d49ffcce7a5b6d6891438b837b3b26ba9db",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_24.0.0-alpha.0_1539951144113_0.6432423922570261"
      },
      "readme" : "# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.10.0"
    },
    "24.0.0-alpha.5" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "24.0.0-alpha.5",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "engines" : {
        "node" : ">= 6"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-24.0.0-alpha.5.tgz",
        "shasum" : "4f6a3201d5cbc05c4ec85a8782918e40f7c070cf"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "jean@lauliac.com",
        "name" : "jeanlauliac"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      }, {
        "email" : "rubennorte@gmail.com",
        "name" : "rubennorte"
      } ],
      "directories" : {
      },
      "_npmVersion" : "5.6.0",
      "_npmUser" : {
        "name" : "rubennorte",
        "email" : "rubennorte@gmail.com"
      },
      "_id" : "diff-sequences@24.0.0-alpha.5",
      "gitHead" : "2c18a53e8ff2437bba5fcb8076b754ac5f79f9f8",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_24.0.0-alpha.5_1541769147515_0.16601082038693682"
      },
      "readme" : "# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.11.3"
    },
    "24.0.0-alpha.6" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "24.0.0-alpha.6",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "engines" : {
        "node" : ">= 6"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-24.0.0-alpha.6.tgz",
        "shasum" : "d1421aad3daa4a0c412b8653582283be34cc652c"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "jean@lauliac.com",
        "name" : "jeanlauliac"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      }, {
        "email" : "rubennorte@gmail.com",
        "name" : "rubennorte"
      } ],
      "directories" : {
      },
      "_npmVersion" : "5.6.0",
      "_npmUser" : {
        "name" : "rubennorte",
        "email" : "rubennorte@gmail.com"
      },
      "_id" : "diff-sequences@24.0.0-alpha.6",
      "gitHead" : "49d08403a941e596eda1279c07a1eaf4d4a73dad",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_24.0.0-alpha.6_1541785765740_0.5487019499237025"
      },
      "readme" : "# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.11.3"
    },
    "24.0.0-alpha.4" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "24.0.0-alpha.4",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "engines" : {
        "node" : ">= 6"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-24.0.0-alpha.4.tgz",
        "shasum" : "b77b2500545c5450f73c7cf79692d433941e3fc3"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "jean@lauliac.com",
        "name" : "jeanlauliac"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      }, {
        "email" : "rubennorte@gmail.com",
        "name" : "rubennorte"
      } ],
      "directories" : {
      },
      "_npmVersion" : "5.6.0",
      "_npmUser" : {
        "name" : "rubennorte",
        "email" : "rubennorte@gmail.com"
      },
      "_id" : "diff-sequences@24.0.0-alpha.4",
      "gitHead" : "e41f0bb257c6652c3100b97a1087f9f812fbea0d",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_24.0.0-alpha.4_1540571577591_0.5130622776524432"
      },
      "readme" : "# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.11.3"
    },
    "22.2.0" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "22.2.0",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-22.2.0.tgz",
        "shasum" : "46a0e57335062a1bd4d1a8b88dd5aab4207307e7"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      } ],
      "directories" : {
      },
      "_npmVersion" : "5.5.1",
      "_npmUser" : {
        "name" : "mjesun",
        "email" : "mjesun@hotmail.com"
      },
      "_id" : "diff-sequences@22.2.0",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_22.2.0_1517999151975_0.5374213453134911"
      },
      "_nodeVersion" : "8.9.1"
    },
    "23.0.1" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "23.0.1",
      "repository" : {
        "type" : "git",
        "url" : "https://github.com/facebook/jest.git"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-23.0.1.tgz",
        "shasum" : "7c0ec0a9ad5c7ce4395ba948a8f040489c88ab2d"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      } ],
      "directories" : {
      },
      "_npmUser" : {
        "name" : "mjesun",
        "email" : "mjesun@hotmail.com"
      },
      "_id" : "diff-sequences@23.0.1",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_23.0.1_1527435037960_0.3578688685807707"
      }
    },
    "23.2.0" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "23.2.0",
      "repository" : {
        "type" : "git",
        "url" : "https://github.com/facebook/jest.git"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-23.2.0.tgz",
        "shasum" : "77b4ce1229345db8744a8be5064063d6072c9678"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      } ],
      "directories" : {
      },
      "_npmUser" : {
        "name" : "mjesun",
        "email" : "mjesun@hotmail.com"
      },
      "_id" : "diff-sequences@23.2.0",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_23.2.0_1529935507744_0.33531794695212747"
      }
    },
    "23.6.0" : {
      "name" : "diff-sequences",
      "description" : "Compare items in two sequences to find a longest common subsequence",
      "version" : "23.6.0",
      "homepage" : "https://github.com/facebook/jest#readme",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/facebook/jest.git"
      },
      "bugs" : {
        "url" : "https://github.com/facebook/jest/issues"
      },
      "main" : "build/index.js",
      "dist" : {
        "tarball" : "https://build-artifactory.eng.vmware.com/api/npm/npm/diff-sequences/-/diff-sequences-23.6.0.tgz",
        "shasum" : "313fbfaedd00565a143521a4ab05e007e3db297d"
      },
      "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
      "license" : "MIT",
      "maintainers" : [ {
        "email" : "christoph.pojer@gmail.com",
        "name" : "cpojer"
      }, {
        "email" : "mjesun@hotmail.com",
        "name" : "mjesun"
      } ],
      "directories" : {
      },
      "_npmVersion" : "5.5.1",
      "_npmUser" : {
        "name" : "mjesun",
        "email" : "mjesun@hotmail.com"
      },
      "_id" : "diff-sequences@23.6.0",
      "_hasShrinkwrap" : false,
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/diff-sequences_23.6.0_1536583366712_0.4829199435875795"
      },
      "_nodeVersion" : "8.9.1"
    }
  },
  "readme" : "# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences').default; // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\nconst a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nconst b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  let n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nconst commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n",
  "maintainers" : [ {
    "email" : "christoph.pojer@gmail.com",
    "name" : "cpojer"
  }, {
    "email" : "davidzilburg@gmail.com",
    "name" : "davidzilburg"
  }, {
    "email" : "jean@lauliac.com",
    "name" : "jeanlauliac"
  }, {
    "email" : "mjesun@hotmail.com",
    "name" : "mjesun"
  }, {
    "email" : "rubennorte@gmail.com",
    "name" : "rubennorte"
  }, {
    "email" : "scott.hovestadt@gmail.com",
    "name" : "scotthovestadt"
  } ],
  "time" : {
    "24.0.0-alpha.16" : "2019-01-25T13:41:47.951Z",
    "24.0.0" : "2019-01-25T15:04:42.491Z",
    "24.0.0-alpha.15" : "2019-01-24T17:52:16.859Z",
    "24.0.0-alpha.12" : "2019-01-11T14:58:02.904Z",
    "24.0.0-alpha.13" : "2019-01-23T15:15:16.318Z",
    "24.0.0-alpha.10" : "2019-01-09T17:00:58.838Z",
    "24.0.0-alpha.11" : "2019-01-10T18:41:24.557Z",
    "24.9.0" : "2019-08-16T05:55:47.104Z",
    "24.2.0" : "2019-03-05T11:22:43.927Z",
    "24.3.0" : "2019-03-07T12:59:18.867Z",
    "0.0.0" : "2018-02-07T08:27:15.381Z",
    "25.0.0" : "2019-08-22T03:23:44.608Z",
    "24.0.0-alpha.9" : "2018-12-19T14:22:53.561Z",
    "modified" : "2020-01-22T00:59:50.616Z",
    "24.0.0-alpha.7" : "2018-12-11T16:07:30.526Z",
    "25.1.0" : "2020-01-22T00:59:44.659Z",
    "24.2.0-alpha.0" : "2019-03-05T14:46:21.974Z",
    "24.0.0-alpha.1" : "2018-10-22T15:35:28.176Z",
    "24.0.0-alpha.2" : "2018-10-25T10:31:40.220Z",
    "22.4.3" : "2018-03-21T16:07:58.704Z",
    "24.0.0-alpha.0" : "2018-10-19T12:12:24.277Z",
    "24.0.0-alpha.5" : "2018-11-09T13:12:27.668Z",
    "24.0.0-alpha.6" : "2018-11-09T17:49:25.919Z",
    "created" : "2018-02-07T08:27:14.570Z",
    "24.0.0-alpha.4" : "2018-10-26T16:32:58.114Z",
    "22.2.0" : "2018-02-07T10:25:52.632Z",
    "23.0.1" : "2018-05-27T15:30:39.544Z",
    "23.2.0" : "2018-06-25T14:05:07.827Z",
    "23.6.0" : "2018-09-10T12:42:46.921Z"
  },
  "repository" : {
    "type" : "git",
    "url" : "git+https://github.com/facebook/jest.git",
    "directory" : "packages/diff-sequences"
  },
  "users" : {
  },
  "readmeFilename" : "README.md",
  "homepage" : "https://github.com/facebook/jest#readme",
  "keywords" : [ "fast", "linear", "space", "callback", "diff" ],
  "bugs" : {
    "url" : "https://github.com/facebook/jest/issues"
  },
  "license" : "MIT"
}